/*
 - (이론) 지역변수 전역변수 동적할당 된 변수, static변수는 메모리 영역 중 어디에 할당되고, 할당 시점과 소멸 시점에 대해서 설명을 기입.
 -> 설명 : 지역변수 : 스택 영역(할당 시점 : 변수 선언 직후, 소멸 시점 : {}의 지역이 끝났을 때)
	   전역변수 : 데이터 영역(할당 시점 : 변수 선언 직후, 소멸 시점 : 프로그램이 끝났을 때)
	   동적할당 된 변수 : 힙 영역(할당 시점 : 변수를 new로 선언 했을 때, 소멸 시점 : 변수를 delete 했을 때)
	   static변수 : 데이터 영역(할당 시점 : 변수 선언 직후, 소멸 시점 : 프로그램이 끝났을 때)

 - (이론) 동적할당을 한 뒤, 그대로 종료하면 무슨일이 일어나는지, 또한 그것이 계속 반복된다면 어떻게 되는지 기입.
 -> 설명 : 그대로 종료하면 메모리 누수가 일어납니다. 메모리 누수가 계속 반복된다면 프로그램 응답속도가 늦어지면서 성능 저하를 불러옵니다. 이는 결국 OutOfMemory Error로 프로그램이 종료되게 됩니다.

 - (이론) lvalue와 rvalue의 차이에 대해서 설명하시오.
 -> 설명 : lvalue : 표현식 이후에도 사라지지 않는 값, 이름을 지니는 변수. rvalue : 표현식 이후에는 사라지는 임시적인 값, 임시 변수.

 - (이론) 함수의 오버로딩과 오버라이딩의 차이에 대해서 서술하시오.
 -> 설명 : 함수의 오버로딩은 매개변수를 다르게해서 같은 형태의 함수를 여러 방식으로 사용하는 것입니다. 함수의 오버라이딩은 부모에서 정의된 함수를 virtual 키워드를 통해서 자식에서 재 정의를 통해 자식의 함수를 사용하는 것입니다.

 - (이론) 함수의 호출이 반복적으로 쌓인다면 무슨일이 일어나고, 쌓일 수 있는 최대 허용량을 넘어서면 어떤 일이 일어나는지 서술하시오.
 -> 설명 : 함수의 호출이 반복적으로 쌓이면 스택에 데이터가 쌓이게 되고 허용량을 넘어서면 스택 오버플로우가 일어나 컴파일이 불가능 해집니다.

 - (이론) 배열이 메모리 구조상 연속적으로 할당됨으로서 얻을 수 있는 이점을 설명하시오.
 -> 설명 : 메모리 구조상에 연속적으로 할당됨으로서 원하는 데이터에 빨리 접근 할 수있습니다.

 - (이론) STL이란 무엇인지 설명하시오.
 -> 설명 : STL이란 Standard Template Library라고 부르며 프로그램에 필요한 자료구조와 알고리즘을 Template로 제공하는 라이브러리입니다.

 - (이론) 일반적인 정적 배열과 벡터의 차이점에 대해서 설명하시오.
 -> 설명 : 벡터는 배열에 비해서 메모리의 재할당이 용이합니다. 배열은 Index 기반 랜덤접근을 하지만 벡터는 Iterator 기반 랜덤접근

 - (이론) push_back과 emplace_back의 차이점에 대해 설명하시오.
 -> 설명 : push_back 함수는 '객체' 를 집어 넣는 형식으로, 객체가 없이 삽입을 하려면 "임시객체 (rvalue) " 가 있어야 합니다.
	emplace_back 함수는 C++11 에서 도입된 함수로서, 가변인자 템플릿을 사용하여 객체 생성에 필요한 인자만 받은 후함수 내에서 객체를 생성해 삽입하는 방식입니다.
	임시 객체를 만들 필요가 없기 때문에, emplace_back 내부에서 삽입에 필요한 생성자 한번만 호출 됩니다.

 - (이론) 배열과 포인터는 어떤 상관관계가 있는지 짧게 서술하시오.
 -> 설명 : 포인터는 주소를 사용하고 배열은 원소에 접근하기 위해서 연속된 메모리 공간을 사용하는데 이 때 배열의 시작 주소를 통해서 빠르게 원소의 위치에 접근할 수 있습니다.

 - (이론) 참조자와 포인터는 무슨 차이가 있는지 서술하시오. (사용의 차이에 대하여)
 -> 설명 :
	1. null초기화 : 포인터는 null초기화 가능 레퍼런스는 불가능 또한 반드시 선언과 동시에 초기화 필요
	2. 메모리 공간의 소모 : 포인터는 주소값을 저장하기위해 별도의 메모리 공간 사용, 레퍼런스는 별명이기 ‹š문에 같은 메모리 공간 참조
	3. 주소 전달방식(call by address), 참조 전달방식(call by reference)

 - (이론) 객체지향으로서의 객체는 무엇인가 ?
 -> 설명 : 객체지향으로서의 객체는 속성과 기능을 가지고 사용할 수 있는 객체입니다.

 - (이론) 객체지향의 3요소 5원칙에 대해서 서술하시오.
 -> 설명 : 객체지향의 요소에는 다형성, 상속성, 캡슐화가 있습니다. 객체지향의 설계 5원칙으로는 SOLID원칙이 있습니다.
	다형성 : 하나의 객체가 여러가지 형태를 가질 수 있습니다. 예) 뮤탈은 가디언과 디바우러 두가지 형태로 변할 수있는 다형성을 가지고 있습니다.
	상속성 : 클래스 사이에는 부모와 자식의 관계가 형성 될 수 있고 부모는 자식에게 속성과 기능을 물려 줄 수 있습니다. 예) 탈것(부모) -> 자동차(자식)
	캡슐화 : 클래스는 속성과 기능을 클래스 내에 모아 둘 수 있고 캡슐화를 통해 정보은닉을 할 수 있습니다. 예) 알약 내부에는 여러 가루들이 들어있지만 우리는 이것이 무엇인지 모르고 먹는다.
	단일 책임의 원칙(S) : 모든 클래스는 각각 하나의 책임만 가져야 한다. 즉, 특수한 목적을 수행하도록 만든 클래스는 해당 목적 외에 다른 기능을 수행하면 안된다.
	개방 폐쇄의 원칙(O) : 클래스는 확장에는 열려있고 수정에는 닫혀있어야 한다. 즉, 기존의 코드를 변경하지 않으면서 기능을 추가할 수 있도록 설계되어야 한다.
	리스코프 치환의 원칙(L) : 자식 클래스는 언제나 자신의 부모 클래스를 대체할 수 있어야 한다. 즉, 자식 클래스는 부모 클래스의 책임을 무시하거나 재정의하지 않고 확장만 수행하도록 해야한다.
	인터페이스 분리 원칙(I) : 한 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다. 하나의 일반적인 인터페이스보다 여러 개의 구체적인 인터페이스가 낫다.
	의존관계 역전 원칙(D) : 의존 관계를 맺을 때 변화하기 쉬운 것 또는 자주 변화하는 것보다는 변화하기 어려운 것, 거의 변화가 없는 것에 의존해야 한다. 즉, 구체적인 클래스보다는 인터페이스나 추상 클래스와 관계를 맺어야 한다.
	좋은 설계를 하기위해서 객체지향의 원칙을 지키고 응집도를 늘리고 결합도를 줄일 필요가 있습니다.

 - (이론) 구조체와 클래스는 모던 C++ 이후 어떠한 차이가 있는가 ?
 -> 설명 : 접근 제어 지시자에 차이가 있습니다. 구조체는 기본이 public이고 클래스는 기본이 private입니다.

 - (이론) 설계단계에서 구조체와 클래스를 구분 한다면 어떤 기준으로 구분하겠는가 ?
 -> 설명 : 정보은닉에 근거해서 숨길 부분은 클래스로 구현하고 다른 객체에서 접근해야하는 부분은 구조체로 구현 할것 같습니다.

 - (이론) 순수가상함수란 무엇인지 서술하시오.
 -> 설명 : 순수 가상함수란 추상클래스라 부르며 부모 클래스에서 사용합니다. 함수를 선언만 하고 0으로 초기화해 자식에서 구현해준다는 의미를 가지고있습니다.

 - (이론) 추상클래스란 무엇인지 서술하고 사용하는 이유에 대해서 설명하시오.
 -> 설명 : C++에서는 하나 이상의 순수 가상함수를 포함하는 클래스를 추상 클래스라고 부릅니다. 추상 클래스는 인터페이스 분리 원칙에 의해서 보다 구체적인 클래스가 만들어질 수 있도록 사용합니다.

 - (이론) is - a관계와 has - a관계가 무엇인지 설명하시오.
 -> 설명 : is - a관계란 일반적인 개념과 구체적인 개념의 관계입니다. 예) 소는 동물이다. 말은 동물이다. 새는 동물이다.
		  has - a 관계란 포함의 관계입니다. 예) 컴퓨터는 CPU와 그래픽카드, RAM 등 여러 클래스를 포함 하고 있습니다.

 - (이론) 캐릭터가 직업을 가진다고 하였을때, 당신은 is - a와 has - a 둘 중 어떤 관계로할 것인가 ? 그 이유에 대해서 서술하시오.
 -> 설명 : is - a 관계 Character가 직업을 가진다고 했을 때 Knight, Maze, Archer로 전직할 수 있다고 하면 직업을 일반화 했을 때 캐릭터가 되고 캐릭터를 구체화 했을 때 직업이 된다라고 표현할 수 있기 때문입니다.

 - (이론) 큐와 스택에 대해서 설명하고 적용되는 예를 하나씩 적어보시오.
 -> 설명 : 큐는 일찍 들어온것이 일찍 나가는 선입 선출 구조(FIFO)를 가지고 있습니다. 예) 은행 : 먼저 대기표를 뽑은 사람이 먼저 일을 처리하러 나간다.
		   스택은 일찍 들어온것이 늦게 나가는 후입 선출 구조(LIFO)를 가지고 있습니다. 예) 쌓아둔 책 : 책을 가져갈 때 위에 책부터 가져갑니다.

 - (이론) 큐와 스택이 배열에 비해서 좋은점이 있다면, 어떤점이 있을지 서술하시오
 -> 설명 : 큐와 스택은 포인터를 통해 데이터에 접근 하기 때문에 배열에 비해서 데이터의 삽입과 삭제가 빠릅니다.

 - (이론)  계속 반복되는 알 수 없는 상수(ex for (int i = 0; i < 195; i++)의 195)를 무엇이라하는가 ?
 -> 설명 : 매직넘버 라고합니다.

 - (이론) 그러한 상수를 쉽게 알아볼 수 있도록 심볼을 부여 하는 것을 무엇이라하는가 ?
 -> 설명 : 심볼릭 상수 입니다.

 - (이론)  #define과 const의 차이에 대해서 설명하시오, 어떤것이 어느 때 더 이점이 있는가 ?
 -> 설명 : #define은 전처리기이기 때문에 심볼릭 상수를 치환해 주는 역할을 하고 const는 변수를 상수화를 시켜줍니다.

 - (이론) const와 constexpr의 차이에 대해서 설명하시오.
 -> 설명 : const는 런타임 시간에도 상수화를 시켜주고 constexpr 컴파일 시간에만 상수화를 시켜줍니다. 그래서 const는 input을 통해서 상수화가 가능합니다.

 - (이론) 예외가 발생하여 throw 1; 을 전달한다 할때, catch가 없으면 어떻게 되는가 ?
 -> 설명 : 에러가 일어납니다.

 - (이론)  throw 1; 을 catch (float errorCode)가 잡을 수 있는가 ? 그렇게 대답한 이유는 무엇인가 ?
 -> 설명 : 잡을 수 없습니다. 1은 정수형 데이터이기 때문에 다른 catch(int error)가 없으면 에러가 일어납니다.

 - (이론) 스택 풀기에 대해서 설명하시오.
 -> 설명 : try catch문을 사용했을때 try의 조건이 만족되고 throw에 의해서 catch로 이동되면 지금까지 들어간 중첩함수에서 빠져나와 함수의 반환을 건너 뛰는 것을 의미합니다.

 - (이론) 템플릿화 하였을때의 장점과 단점을 기입하시오.
 -> 설명 : 템플릿화 하였을때의 장점은 자료형만 다른 함수를 오버로딩을 하지않고 템플릿화를 통해 하나의 함수로 압축할 수 있습니다.
    단점은 다형성으로 인해 파일이 커지면 느려질 수 있고 코드를 읽기가 더 힘들어 집니다.

 - (이론) 추상화 혹은 일반화가 무엇인가, 또 그 반대는 무엇인가
 -> 설명 : 추상화 혹은 일반화란 토끼, 강아지, 고양이 등을 -> 동물 로 간단하게 표현허는 방법입니다. 그 반대로는 탈것 -> 자동차, 비행기, 자전거 등으로 자세히 설명하는 구체화가 있습니다.
 */